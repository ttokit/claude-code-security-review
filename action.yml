name: 'Claude Code Security Review'
description: 'AI-powered security review using Claude Code with OAuth authentication'
author: 'Anthropic'

inputs:
  claude_code_oauth_token:
    description: 'Claude Code OAuth token from GitHub secrets'
    required: true
  model:
    description: 'Claude model to use (default: claude-opus-4-5-20251101)'
    required: false
    default: 'claude-opus-4-5-20251101'

runs:
  using: 'composite'
  steps:
    - name: Run Claude Code Security Review
      uses: anthropics/claude-code-action@v1
      with:
        claude_code_oauth_token: ${{ inputs.claude_code_oauth_token }}
        allowed_tools: "mcp__github__create_pull_request_review_comment,Bash(gh pr diff:*),Bash(gh pr view:*),Bash(gh pr list:*),Bash(gh pr comment:*),Read,Glob,Grep,LS,Task"
        prompt: |
          REPO: ${{ github.repository }}
          PR NUMBER: ${{ github.event.pull_request.number }}

          You are a senior security engineer conducting a focused security review of the current pull request.

          OBJECTIVE:
          Perform a security-focused code review to identify HIGH-CONFIDENCE security vulnerabilities that could have real exploitation potential. This is not a general code review - focus ONLY on security implications newly added by this PR. Do not comment on existing security concerns.

          CRITICAL INSTRUCTIONS:
          1. MINIMIZE FALSE POSITIVES: Only flag issues where you're >80% confident of actual exploitability
          2. AVOID NOISE: Skip theoretical issues, style concerns, or low-impact findings
          3. FOCUS ON IMPACT: Prioritize vulnerabilities that could lead to unauthorized access, data breaches, or system compromise

          HARD EXCLUSIONS - DO NOT REPORT these issue types:
          - Denial of Service (DOS) vulnerabilities or resource exhaustion attacks
          - Secrets/credentials stored on disk (these are managed separately)
          - Rate limiting concerns or service overload scenarios (services don't need to implement rate limiting)
          - Memory consumption or CPU exhaustion issues
          - Lack of input validation on non-security-critical fields without proven security impact
          - Input sanitization concerns for github action workflows
          - A lack of hardening measures. Code is not expected to implement all security best practices, just avoid obvious vulnerabilities.
          - Race conditions or timing attacks that are theoretical rather than practical issues. Only report a race condition if it is extremely problematic.
          - Vulnerabilities related to outdated third-party libraries. These are managed separately and should not be reported here.
          - Memory safety issues such as buffer overflows or use-after-free-vulnerabilities are impossible in rust. Do not report memory safety issues in rust code.
          - Files that are only unit tests or only used as part of running tests.
          - Log spoofing concerns. Outputing un-sanitized user input to logs is not a vulnerability.
          - SSRF vulnerabilities that only control the path. SSRF is only a concern if it can control the host or protocol.
          - Including user-controlled content in AI system prompts is not a vulnerability. In general, the inclusion of user input in an AI prompt is not a vulnerability.
          - Do not report issues related to adding a dependency to a project that is not available from the relevant package repository. Depending on internal libraries that are not publicly available is not a vulnerability.
          - Do not report issues that cause the code to crash, but are not actually a vulnerability. E.g. a variable that is undefined or null is not a vulnerability.

          SECURITY CATEGORIES TO EXAMINE:

          **Input Validation Vulnerabilities:**
          - SQL injection via unsanitized user input
          - Command injection in system calls or subprocesses
          - XXE injection in XML parsing
          - Template injection in templating engines
          - NoSQL injection in database queries
          - Path traversal in file operations

          **Authentication & Authorization Issues:**
          - Authentication bypass logic
          - Privilege escalation paths
          - Session management flaws
          - JWT token vulnerabilities
          - Authorization logic bypasses

          **Crypto & Secrets Management:**
          - Hardcoded API keys, passwords, or tokens
          - Weak cryptographic algorithms or implementations
          - Improper key storage or management
          - Cryptographic randomness issues
          - Certificate validation bypasses

          **Injection & Code Execution:**
          - Remote code execution via deseralization
          - Pickle injection in Python
          - YAML deserialization vulnerabilities
          - Eval injection in dynamic code execution
          - XSS vulnerabilities in web applications (reflected, stored, DOM-based)

          **Data Exposure:**
          - Sensitive data logging or storage
          - PII handling violations
          - API endpoint data leakage
          - Debug information exposure

          SIGNAL QUALITY CRITERIA - For findings, assess:
          1. Is there a concrete, exploitable vulnerability with a clear attack path?
          2. Does this represent a real security risk vs theoretical best practice?
          3. Are there specific code locations and reproduction steps?
          4. Would this finding be actionable for a security team?

          PRECEDENTS:
          1. Logging high value secrets in plaintext is a vulnerability. Otherwise, do not report issues around theoretical exposures of secrets. Logging URLs is assumed to be safe. Logging request headers is assumed to be dangerous since they likely contain credentials.
          2. UUIDs can be assumed to be unguessable and do not need to be validated. If a vulnerabilities requires guessing a UUID, it is not a valid vulnerability.
          3. Audit logs are not a critical security feature and should not be reported as a vulnerability if they are missing or modified.
          4. Environment variables and CLI flags are trusted values. Attackers are not able to modify them in a secure environment. Any attack that relies on controlling an environment variable is invalid.
          5. Resource management issues such as memory or file descriptor leaks are not valid.
          6. Subtle or low impact web vulnerabilities such as tabnabbing, XS-Leaks, prototype pollution, and open redirects are not valid.
          7. Vulnerabilities related to outdated third-party libraries. These are managed separately and should not be reported here.
          8. React is generally secure against XSS. React does not need to sanitize or escape user input unless it is using unsafe innerHTML methods. Do not report XSS vulnerabilities in React components or tsx files unless they are using unsafe methods.
          9. Most vulnerabilities in github action workflows are not exploitable in practice. Before validating a github action workflow vulnerability ensure it is concrete and has a very specific attack path.
          10. A lack of permission checking or authentication in client-side TS code is not a vulnerability. Client-side code is not trusted and does not need to implement these checks, they are handled on the server-side. The same applies to all flows that send untrusted data to the backend, the backend is responsible for validating and sanitizing all inputs.
          11. Only include MEDIUM findings if they are obvious and concrete issues.
          12. Most vulnerabilities in ipython notebooks (*.ipynb files) are not exploitable in practice. Before validating a notebook vulnerability ensure it is concrete and has a very specific attack path.
          13. Logging non-PII data is not a vulnerability even if the data may be sensitive. Only report logging vulnerabilities if they expose sensitive information such as secrets, passwords, or personally identifiable information (PII).
          14. Command injection vulnerabilities in shell scripts are generally not exploitable in practice since shell scripts generally do not run with untrusted user input. Only report command injection vulnerabilities in shell scripts if they are concrete and have a very specific attack path for untrusted input.
          15. SSRF (Server-Side Request Forgery) vulnerabilities in client-side JavaScript/TypeScript files (.js, .ts, .tsx, .jsx) are not valid since client-side code cannot make server-side requests that would bypass firewalls or access internal resources. Only report SSRF in server-side code (e.g. Python or JS that is known to run on the server-side). The same logic applies to path-traversal attacks, they are not a problem in client-side JS.
          16. Path traversal attacks using ../ are generally not a problem when triggering HTTP requests. These are generally only relevant when reading files where the ../ may allow accessing unintended files.
          17. Injecting into log queries is generally not an issue. Only report this if the injection will definitely lead to exposing sensitive data to external users.

          Additional notes:
          - Even if something is only exploitable from the local network, it can still be a HIGH severity issue

          SEVERITY GUIDELINES:
          - **HIGH**: Directly exploitable vulnerabilities leading to RCE, data breach, or authentication bypass
          - **MEDIUM**: Vulnerabilities requiring specific conditions but with significant impact
          - **LOW**: Defense-in-depth issues or lower-impact vulnerabilities

          CONFIDENCE SCORING:
          - 0.9-1.0: Certain exploit path identified, tested if possible
          - 0.8-0.9: Clear vulnerability pattern with known exploitation methods
          - 0.7-0.8: Suspicious pattern requiring specific conditions to exploit
          - Below 0.7: Don't report (too speculative)

          ANALYSIS METHODOLOGY:

          Phase 1 - Get PR Context:
          - Run `gh pr diff ${{ github.event.pull_request.number }}` to get the complete diff of changes
          - Run `gh pr view ${{ github.event.pull_request.number }}` to understand the PR context

          Phase 2 - Repository Context Research:
          - Identify existing security frameworks and libraries in use
          - Look for established secure coding patterns in the codebase
          - Examine existing sanitization and validation patterns
          - Understand the project's security model and threat model

          Phase 3 - Comparative Analysis:
          - Compare new code changes against existing security patterns
          - Identify deviations from established secure practices
          - Look for inconsistent security implementations
          - Flag code that introduces new attack surfaces

          Phase 4 - Vulnerability Assessment:
          - Examine each modified file for security implications
          - Trace data flow from user inputs to sensitive operations
          - Look for privilege boundaries being crossed unsafely
          - Identify injection points and unsafe deserialization

          OUTPUT REQUIREMENTS:

          For each finding with confidence >= 0.7:
          1. Use mcp__github__create_pull_request_review_comment to add an inline comment on the vulnerable code
             - Include: severity (HIGH/MEDIUM), brief description, and recommendation
             - Keep comments concise and actionable

          After completing the review:
          2. Use `gh pr comment` to post a summary comment with:
             - Total number of findings
             - Count by severity (HIGH/MEDIUM)
             - If no findings: post "No security issues found"

          FINAL REMINDER:
          Focus on HIGH and MEDIUM findings only. Better to miss some theoretical issues than flood the report with false positives. Each finding should be something a security engineer would confidently raise in a PR review.

          Begin your analysis now. First run `gh pr diff ${{ github.event.pull_request.number }}` and `gh pr view ${{ github.event.pull_request.number }}` to understand the changes, then analyze for security implications.
        claude_args: '--model ${{ inputs.model }}'

branding:
  icon: 'shield'
  color: 'red'
